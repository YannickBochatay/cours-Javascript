<qcm>
  <code>let toto = "tata";
typeof toto;</code>
  <question>Ce code renvoie</question>
  <choix correct>"string"</choix>
  <choix>"object"</choix>
  <reponse>Une variable contenant une chaîne de caractères est de type primitif "string"</reponse>
</qcm>

<qcm>
  <code>let toto = " tata ";
let tata = toto.trim(); //la méthode trim supprime les blancs en début et fin de chaîne
typeof tata;</code>
  <question>Ce code renvoie</question>
  <choix correct>"string"</choix>
  <choix>"object"</choix>
  <reponse>La méthode renvoie une nouvelle valeur primitive de type "string", que l'on stocke dans la variable tata.</reponse>
</qcm>

<qcm>
  <code>let toto = " tata ";
typeof toto.trim();</code>
  <question>Ce code renvoie</question>
  <choix correct>"string"</choix>
  <choix>"object"</choix>
  <reponse>La méthode renvoie une nouvelle valeur primitive de type "string", que celle-ci soit stockée ou non dans une variable.</reponse>
</qcm>

<qcm>
  <code>let toto = " tata ";
toto.trim();</code>
	<question>Après exécution de ce code, la variable toto vaut</question>
	<choix>"tata"</choix>
	<choix correct>" tata "</choix>
  <reponse>La méthode ne modifie pas la variable elle-même mais renvoie une nouvelle valeur primitive.</reponse>
</qcm>

<qcm>
  <code>let toto = " tata ";
let tata = toto.trim();</code>
  <question>Après exécution de ce code, la variable tata vaut</question>
  <choix correct>"tata"</choix>
  <choix>" tata "</choix>
  <reponse>La méthode renvoie une nouvelle valeur primitive dont les blancs ont été supprimés en début et fin de chaîne.</reponse>
</qcm>

<qcm>
  <code>let toto = "tata";

`Mon nom est ${  toto + 1  }`;</code>
  <question>La chaîne renvoie</question>
  <choix>Error</choix>
  <choix>"Mon nom est 2"</choix>
  <choix>"Mon nom est ${ toto + 1 }"</choix>
  <choix correct>"Mon nom est tata1"</choix>
  <choix>"Mon nom est&nbsp;&nbsp;&nbsp;tata1&nbsp;&nbsp;"</choix>
  <reponse>La méthode renvoie une nouvelle valeur primitive dont les blancs ont été supprimés en début et fin de chaîne.</reponse>
</qcm>

<qcm>
  <code>let nb = 25;
nb.toFixed(2);</code>
  <question>Après exécution de ce code, la variable nb vaut</question>
  <choix correct>25</choix>
  <choix>"25.00"</choix>
  <reponse>La méthode ne modifie pas la variable elle-même mais renvoie une nouvelle valeur primitive.</reponse>
</qcm>

<qcm>
  <code>let nb = 25;
let str = nb.toFixed(2);</code>
  <question>Après exécution de ce code, la variable str vaut</question>
  <choix>25</choix>
  <choix correct>"25.00"</choix>
  <reponse>La méthode renvoie une chaîne de caractères formatée en notation à point fixe.</reponse>
</qcm>

<qcm>
  <code>let age = new Number(25);</code>
  <question>Cette écriture peut s'avérer utile</question>
  <choix>oui</choix>
  <choix correct>non</choix>
  <reponse>Même si c'est possible, les constructeurs Boolean, String, Number ne sont jamais invoqués avec l'opérateur new. C'est inutile et source d'erreurs.
Les conversions automatiques de javascript permettent une écriture plus intuitive.
  </reponse>
</qcm>

<qcm>
  <code>let age = Number("25");</code>
  <question>Cette écriture peut s'avérer utile</question>
  <choix correct>oui</choix>
  <choix>non</choix>
  <reponse>L'invocation des constructeurs Boolean, String et Number sans le mot clé new permet de convertir l'argument en valeur primitive correspondante.</reponse>
</qcm>

<qcm>
  <code>let age = Number(25);
typeof age;</code>
  <question>Ce code renvoie</question>
  <choix>"string"</choix>
  <choix>"object"</choix>
  <choix correct>"number"</choix>
  <choix>Error</choix>
  <reponse>Si l'argument est déjà un nombre, ce même nombre est renvoyé sans générer d'erreur.</reponse>
</qcm>

<qcm>
  <code>let age = Number("25");
typeof age;</code>
  <question>Ce code renvoie</question>
  <choix>"string"</choix>
  <choix>"object"</choix>
  <choix correct>"number"</choix>
  <reponse>La chaîne de caractères "25" est convertie en nombre 25, de type "number"</reponse>
</qcm>

<qcm>
  <code>let age = Number(true);</code>
  <question>La variable age vaut</question>
  <choix>Error</choix>
  <choix>NaN</choix>
  <choix>0</choix>
  <choix correct>1</choix>
  <reponse>La conversion d'un booléen true en nombre renvoie 1. La conversion de la valeur booléenne false renvoie 0.</reponse>
</qcm>

<qcm>
  <code>let bool = Boolean("toto");</code>
  <question>La variable bool vaut</question>
  <choix>Error</choix>
  <choix correct>true</choix>
  <choix>false</choix>
  <reponse>La conversion en booléen de toute chaîne non vide ("") renvoie true.</reponse>
</qcm>

<qcm>
  <code>let tempe = "25.5°C";
Number(tempe);</code>
  <question>Ce code renvoie</question>
  <choix>"25.5"</choix>
  <choix>25.5</choix>
  <choix>25</choix>
  <choix correct>NaN</choix>
  <reponse>Si la chaîne contient des caractères non numériques, la conversion en nombre renvoie la valeur spéciale NaN (not a number).</reponse>
</qcm>

<qcm>
  <code>let tempe = "25.5°C";
Number.parseInt(tempe);</code>
  <question>Ce code renvoie</question>
  <choix>"25.5"</choix>
  <choix>25.5</choix>
  <choix correct>25</choix>
  <choix>26</choix>
  <choix>NaN</choix>
  <reponse>Le fonctionnement de la fonction parseInt est différent : elle s'arrête dès qu'elle trouve un caractère non numérique.
    "25.5" est retenu et est tronqué à la valeur entière 25.</reponse>
</qcm>

<qcm>
  <code>let tempe = "25.5°C";
Number.parseFloat(tempe);</code>
  <question>Ce code renvoie</question>
  <choix>"25.5"</choix>
  <choix correct>25.5</choix>
  <choix>25</choix>
  <choix>26</choix>
  <choix>NaN</choix>
  <reponse>Le fonctionnement de parseFloat est le même que celui de parseInt, sauf que le nombre n'est pas tronqué.</reponse>
</qcm>
