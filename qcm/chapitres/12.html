    		<qcm>
    			<code>class Personne {
  constructor() { this.nom = "toto"; }
}

let obj = new Personne();
typeof obj;</code>
    			<question>La dernière instruction renvoie</question>
    			<choix>Error</choix>
    			<choix>"undefined"</choix>
    			<choix>"string"</choix>
          <choix correct>"object"</choix>
          <reponse>Les instances de classe sont toujours de type objet</reponse>
    		</qcm>

    		<qcm>
    			<code>class Personne {
  constructor() { this.nom = "toto"; }
}

let obj = new Personne();
typeof obj.nom;</code>
    			<question>La dernière instruction renvoie</question>
    			<choix>Error</choix>
    			<choix>"undefined"</choix>
    			<choix correct>"string"</choix>
          <choix>"object"</choix>
          <reponse>La proriété nom définie à l'instanciation est de type chaîne</reponse>
    		</qcm>

    		<qcm>
    			<code>class Personne {
  constructor(age) { this.age = age; }
}

let toto = new Personne();
typeof toto.age;</code>
    			<question>La dernière instruction renvoie</question>
    			<choix>Error</choix>
    			<choix correct>"undefined"</choix>
    			<choix>"string"</choix>
          <choix>"object"</choix>
          <reponse>Un argument non passé à la valeur undefined</reponse>
        </qcm>

        <qcm>
          <code>class Personne {
  constructor(age) {
    this.age = age;
    this._activiteSecrete = "espion";
  }
}

let toto = new Personne();
toto._activiteSecrete;</code>
          <question>La dernière instruction renvoie</question>
          <choix>Error</choix>
          <choix correct>"espion"</choix>
          <choix>"undefined"</choix>
          <reponse>L'underscore était juste une convention de nommage avant la normalisation des variables privées en ES2022</reponse>
        </qcm>

    		<qcm>
    			<code>class Personne {
  constructor(nom) { this.nom = nom; }
  static test(obj) { return obj instanceof Personne; }
}

let toto = new Personne("Toto");
typeof toto.test;</code>
    			<question>La dernière instruction renvoie</question>
    			<choix>Error</choix>
    			<choix correct>"undefined"</choix>
    			<choix>"function"</choix>
          <choix>"object"</choix>
          <reponse>Les méthodes statiques ne sont pas accessibles à partir des instances, seulement à partir du constructeur (classe).</reponse>
        </qcm>

        <qcm>
            <code>class Personne {
  constructor(nom, age) {
    this.nom = nom;
    this.age = age;
  }
  vieillir() {
    this.age++;
  }
}

class Anxieux extends Personne {
  constructor(nom, age) {
    super(nom, age);
    this.anxiete = 10;
  }
  vieillir() {
    super.vieillir();
    this.anxiete++;
  }
}

let toto = new Anxieux("Toto",25);
toto.vieillir();
toto.age;</code>
            <question>La dernière instruction renvoie</question>
            <choix>25</choix>
            <choix correct>26</choix>
            <choix>Error</choix>
          </qcm>

    		<qcm>
    			<code>class Personne {
  constructor(nom) { this.nom = nom; }
}

let toto = new Personne("Toto");
toto.toString();
</code>
    			<question>La dernière instruction renvoie</question>
    			<choix>Error</choix>
    			<choix correct>"[object Object]"</choix>
          <choix>undefined</choix>
          <reponse>Tous les objets héritent du constructeur Object, qui contient la méthode toString</reponse>
    		</qcm>

    		<qcm>
    			<code>class Personne {
  constructor(nom) { this.nom = nom; }
  toString() { return "[object Personne]"; }
}

let toto = new Personne("Toto");
toto.toString();
</code>
    			<question>La dernière instruction renvoie</question>
    			<choix>Error</choix>
    			<choix>"[object Object]"</choix>
          <choix correct>"[object Personne]"</choix>
          <reponse>La méthode toString a été surchargée</reponse>
    		</qcm>

    		<qcm>
    			<code>class Personne {
  constructor(nom) { this.nom = nom; }
  toString() { return "[object Personne]"; }
}

let toto = new Personne("Toto");
console.log("toto : " + toto);
</code>
    			<question>La dernière instruction renvoie</question>
    			<choix>Error</choix>
    			<choix>"toto : undefined"</choix>
    			<choix>"toto : [object Object]"</choix>
          <choix correct>"toto : [object Personne]"</choix>
          <reponse>La méthode toString est utilisée en interne pour convertir un objet en chaîne de caractère.</reponse>
    		</qcm>

    		<qcm>
    			<code>class Personne {
  constructor(nom, age) {
    this.nom = nom;
    this._age = age;
  }
  get age() {
    return this._age;
  }
  set age(val)  {
    if (typeof val !== "number") throw new TypeError("val n'est pas un nombre");
    this._age = val;
  }
}

let toto = new Personne("Toto",25);
toto.age;
</code>
    			<question>La dernière instruction renvoie</question>
    			<choix correct>25</choix>
    			<choix>undefined</choix>
          <choix>Error</choix>
          <reponse>Le mutateur (set) a été utilisé à la construction pour instancier la propriété _age, renvoyée par l'accesseur (get).</reponse>
        </qcm>

        <qcm>
            <code>class Personne {
  constructor(nom, age) {
    this.nom = nom;
    this._age = age;
  }
  get age() {
    return this._age;
  }
  set age(val)  {
    if (typeof val !== "number") throw new TypeError("val n'est pas un nombre");
    this._age = val;
  }
}

let toto = new Personne("Toto",25);
toto.age = "titi";</code>
            <question>La dernière instruction renvoie</question>
            <choix>true</choix>
            <choix>undefined</choix>
            <choix>25</choix>
            <choix correct>Error</choix>
            <reponse>Le mutateur (set) est appelé pour définir la propriété age et jette une erreur car la valeur n'est pas un nombre</reponse>
          </qcm>
